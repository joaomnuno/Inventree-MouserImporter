# InvenTree Part Importer Web App - Requirements and Design

## Overview

This project aims to create a **web application for importing electronic component parts into an InvenTree inventory system**. The tool will streamline part entry by retrieving part details from supplier references (Mouser or Digi-Key) with minimal manual input. Nearly every electronic component comes packaged with a barcode or reference containing key information[\[1\]](https://github.com/maholli/getparts#:~:text=Nearly%20every%20electrical%20component%20ordered,with%20and%20without%20search%20API), and supplier APIs exist to fetch detailed data. By leveraging these barcodes and APIs, we can greatly reduce manual data entry. Ease of use is paramount - if adding parts is too tedious, users will avoid the inventory system[\[2\]](https://github.com/inventree/InvenTree/issues/677#:~:text=I%20wanted%20to%20get%20this,to%20reinvent%20the%20wheel%20here). This app will therefore focus on **intuitive scanning, automatic data retrieval, and seamless integration with InvenTree**.

## Key Functional Requirements

### 1\. Accepting Part References (Barcode or Text)

- **Input Methods**: Users can input a Mouser or Digi-Key part reference either by typing the part number/SKU or by scanning a barcode/QR code on the part packaging. The app will support USB barcode scanners (HID keyboard mode) as well as device cameras for scanning. Using a 2D barcode (DataMatrix/QR) from the package is preferred for rich data[\[3\]](https://github.com/maholli/getparts#:~:text=Always%20starts%20with%20%60%5B%29%3E%60%20,and), but 1D codes can be used if they contain the part number.
- **Mobile Camera Scanning**: The web UI should allow activating a smartphone or webcam to scan labels. This makes it convenient to scan Mouser/Digi-Key bag labels using a phone's camera. The system will decode 1D/2D barcodes on the fly (e.g. DataMatrix codes on Mouser bags, which start with \]>\\) and contain the part info[\[4\]](https://github.com/maholli/getparts#:~:text=,and)).
- **Auto-detection**: If possible, the app should auto-detect the supplier from the scanned data format. For example, Digi-Key 2D codes have a specific prefix and can use Digi-Key's barcode API[\[4\]](https://github.com/maholli/getparts#:~:text=,and), whereas Mouser 2D codes contain the part number that we'll use with Mouser's API[\[5\]](https://github.com/maholli/getparts#:~:text=data%20matrix%20format.%20,Invoice%20No). (In practice, we will extract the Mouser Part Number from the DataMatrix and use the search API, since Mouser has no direct barcode lookup[\[5\]](https://github.com/maholli/getparts#:~:text=data%20matrix%20format.%20,Invoice%20No).)
- **Manual Entry Fallback**: If a barcode is unreadable, users can manually enter the manufacturer part number or the supplier's part number (SKU) and select the supplier.

### 2\. Fetching Part Details from Supplier APIs

- **Mouser API Integration**: When a Mouser reference is provided, the app will call Mouser's **Search API** to get part details. Mouser provides a _Search by Part Number_ endpoint (up to 50 results per call)[\[6\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Method)[\[7\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,to%201%2C000%20calls%20per%20day). We will use the **SearchByPartNumber** method by sending the Mouser Part Number and our API key in a POST request to Mouser's API (e.g. POST <https://api.mouser.com/api/v1/search/partnumber?apikey=&lt;API_KEY>&gt; with a JSON body containing the part number)[\[8\]](https://stackoverflow.com/questions/75205725/no-search-results-while-using-api-key-to-retrieve-information-using-python#:~:text=data%20%3D%20%7B%20,part_number%20%7D). A valid API key (for Mouser's search API) must be obtained and configured[\[9\]](https://github.com/30350n/inventree-part-import#:~:text=match%20at%20L408%20Request%20a,from%20the%20Mouser%20API%20Hub). The response will include rich data: for example, manufacturer name, manufacturer part number, Mouser SKU, description, product category, data sheet link, availability, packaging, compliance, and more[\[10\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Packaging). It also provides pricing info (up to 4 price breaks), lifecycle status, MOQ, order multiples, lead time, etc.[\[11\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,up%20to%204%20price%20breaks) - all of which are useful for inventory records. The app should parse this response and extract key fields (detailed below).
- **Digi-Key API Integration**: When a Digi-Key reference is provided, the app will use Digi-Key's **Product Information API (v4)**. Digi-Key offers endpoints like _ProductDetails_ for a given part number to retrieve comprehensive product data[\[12\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=ProductDetails). The app should call the ProductDetails endpoint with either the Digi-Key part number or the manufacturer part number (Digi-Key's API accepts both)[\[13\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=i%20%20Learn%20More). For example, a GET request to Digi-Key's product endpoint (exact URL determined by their API documentation) will return a single matching product's specs. If the part number isn't exact or multiple matches exist, a broader _KeywordSearch_ may be used first[\[14\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=Enter%20parameters%2C%20keywords%2C%20or%20a,that%20MyPricing%20is%20not%20returned), but in most cases the exact reference yields a unique result. **Authentication**: Note that Digi-Key's API requires OAuth2 authentication with a Client ID/Secret. We will need to register a Digi-Key API application (enabling the "Product Information V4" API)[\[15\]](https://github.com/30350n/inventree-part-import#:~:text=match%20at%20L401%20Register%20a,API%20for%20it) and store the credentials. The app must implement the client credentials OAuth flow to obtain an access token for API calls[\[16\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=DIGIKEY_CLIENT_ID%3Dos.getenv%28)[\[17\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=url%2C%20headers%20%3D%20%7B%20%22X,%7D%2C%20data%20%3D%20json.dumps%28data_payload). Once authenticated, we include the token and our Client ID in requests to Digi-Key's API. (Mouser's API by contrast uses a simple API key for auth[\[9\]](https://github.com/30350n/inventree-part-import#:~:text=match%20at%20L408%20Request%20a,from%20the%20Mouser%20API%20Hub).)
- **Data Fields to Retrieve**: For each part, the app should gather at minimum:
- **Part Name / Description** - a concise description of the part.
- **Manufacturer Name** and **Manufacturer Part Number (MPN)**.
- **Supplier Name** (Mouser or Digi-Key) and their **SKU/Part Number**.
- **Category** - the high-level category or family (e.g. _Resistors -> Thick Film Resistors_). Both APIs return a category path or classification for the part.
- **Primary Attributes** - e.g. value (resistance, capacitance, etc.), size/package (e.g. 0603, SOT-223), tolerance, voltage or power rating, etc., as applicable to the part. (These are typically available in the detailed specs from the APIs. For instance, Digi-Key's ProductDetails returns a list of specifications and Mouser provides parametric data in the results.)
- **Datasheet URL** - link to the datasheet PDF[\[18\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Packaging).
- **Image URL** - link to product image (Mouser provides an image URL[\[18\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Packaging); Digi-Key as well via its Media endpoint if needed).
- **Availability/Stock** - supplier's stock quantity and lead time (if provided, e.g. Mouser's availability and lead time[\[11\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,up%20to%204%20price%20breaks)).
- **Pricing** - at least the default unit price and possibly price breaks. Mouser's API gives up to 4 price breaks[\[11\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,up%20to%204%20price%20breaks), Digi-Key's API can provide pricing via ProductPricing or in the ProductDetails (including account-specific pricing if applicable)[\[19\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=Enter%20a%20manufacturer%20part%20number%2FDigiKey,MyPricing%20is%20shown%20if%20applicable). We will fetch the pricing in the default currency for the region (see Localization below).
- **Miscellaneous** - any other important tags like RoHS compliance, lifecycle status (active/discontinued)[\[11\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,up%20to%204%20price%20breaks) which could be recorded in InvenTree as part attributes or notes.

### 3\. User Review and Mapping to InvenTree

- After fetching data, the app will present the part information to the user for confirmation and editing. **All key fields will be pre-filled** to reduce typing. The user can make adjustments if needed (e.g. tweak the part name or choose a different category) before committing the import.
- **Category Selection**: The app should suggest an InvenTree category for the new part based on the supplier's category data. For example, if Mouser's API says the part is in "Resistors -> Chip Resistors", the app can attempt to find a corresponding category in the InvenTree system. If the category structure in InvenTree is different, the user should be able to select the appropriate category manually (perhaps via a dropdown of InvenTree categories). To facilitate this, the app can fetch the category list from InvenTree via API at startup. We may also maintain a mapping of supplier category names to InvenTree categories (similar to how the CLI tool allows configuring category aliases[\[20\]](https://github.com/30350n/inventree-part-import#:~:text=,defaults%20to%20category%20name)[\[21\]](https://github.com/30350n/inventree-part-import#:~:text=_aliases%3A%20,SMD)). In ambiguous cases or if multiple close matches are found, the UI can present a short list of suggestions for the user to pick from (the CLI version similarly supports interactive category matching[\[22\]](https://github.com/30350n/inventree-part-import#:~:text=temporarily%20blocked%29%20,dataclass)).
- **Parameter Mapping**: Many parts have specific parameters (like resistance, capacitance, tolerance, voltage, etc.). InvenTree allows storing these as Part Parameters. The app should take the key attributes from the API and map them to InvenTree's defined parameters. For instance, if the part is a resistor, the parameter "Resistance" with value "10 kΩ" could be assigned. The app will be configured with or fetch the list of parameter templates from InvenTree (via /api/part/parameter/template/). If a relevant parameter template exists, it will attach the parameter to the part. The UI can show which parameters will be added (and possibly allow the user to deselect some or enter additional info). This mapping can be aided by configuration (like a ruleset that says for category "Resistors" use parameters X, Y, Z)[\[23\]](https://github.com/30350n/inventree-part-import#:~:text=%2A%20%60_ignore%60%20makes%20%60inventree,yaml%29%20this%20category%20uses)[\[24\]](https://github.com/30350n/inventree-part-import#:~:text=_structural%3A%20true%20,the%20%27Ceramic%27%20and%20%27Electrolytic%27%20categories), but initially a simple approach is to take a few common properties.
- **Multiple Match Handling**: In cases where a part number search returns multiple results (e.g. a partial MPN or a generic manufacturer part that could refer to variants), the app should present a list of possible matches with identifying details (MPN, manufacturer, description) for the user to choose. This will ensure the correct item is imported. (The design can mimic the CLI's _interactive part selection_ which lists multiple matches in a user-friendly format[\[25\]](https://github.com/30350n/inventree-part-import#:~:text=in%20interactive%20mode%20,MPN).) Only after a unique part is selected will the detailed info be fetched/confirmed.
- **Intuitive UI/UX**: The interface will guide the user step-by-step: first input/scan, then display retrieved info, then confirmation. It should be clean and uncluttered, using clear labels and logical grouping (e.g. basic info, specifications, pricing). **Defaults and automation** are used wherever possible - for example, if using a barcode scanner that sends a newline, the app can auto-trigger the search after a scan (so the user doesn't have to click a button). Likewise, when using a camera scan, the capture and decode should feed directly into the search. The goal is that a user can go from scanning a bag to having a fully populated part entry with just one or two clicks.

### 4\. Creating/Updating InvenTree Records via API

Once the user confirms, the app will use **InvenTree's REST API** to create the new part and related records in the inventory system. InvenTree provides a comprehensive API for parts and categories[\[26\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=,POST%20%2Fapi%2Fpart%2Fcategory). Key actions:  
\- **Create Part**: The app will send a POST request to InvenTree's /api/part/ endpoint to create the part[\[26\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=,POST%20%2Fapi%2Fpart%2Fcategory). The payload will include fields such as name, description, category (by ID), and flags like **purchaseable** (since these are purchasable components). It may also set initial values like default stock location or default supplier if needed (though these can be updated later). If the part category does not exist in InvenTree yet, the app could optionally create it via /api/part/category/ (or prompt the user to create it).  
\- **Manufacturer and Supplier Info**: The app should also link the part to its manufacturer and supplier details:  
\- _Manufacturer Part_: If the manufacturer (e.g. Vishay, STMicroelectronics) exists in InvenTree as a company, the app will create a **ManufacturerPart** entry linking the new part to the manufacturer and recording the MPN. If the manufacturer company doesn't exist, we could create a new company record via the API or require it to be pre-created. (In a simple implementation, we might skip explicit manufacturer linking, but for completeness it's good to record the MPN and maker.)  
\- _Supplier Part_: Create a **SupplierPart** entry linking the part to Mouser or Digi-Key as the supplier, with the supplier's SKU and pricing. InvenTree's API (likely under the Company or Part endpoints) allows creating supplier part records (with fields for SKU, supplier, manufacturer part link, etc.). For example, using the SupplierPart import mixin in InvenTree can create the supplier part and attach price breaks[\[27\]](https://docs.inventree.org/en/stable/part/#:~:text=Parts%20,parts%20to%20be%20ordered). We will use the supplier's company ID (Mouser and Digi-Key should be set up as suppliers in the InvenTree instance) and provide the SKU and price information obtained. This automates what would otherwise be a manual step of adding supplier links.  
\- _Pricing_: If the API data provides price breaks, the app can add these to the SupplierPart record (InvenTree supports storing price breaks for supplier parts). Initially, we might just record the single-unit price or a standard price, but leaving space to add the full pricing info is beneficial.  
\- **Error Handling**: The app should handle common issues - e.g., if a part with the same MPN or SKU already exists in InvenTree, warn the user or offer to update instead of creating a duplicate. If any API call fails (network issues or the supplier returns no data), show an informative error message (and allow the user to correct or try again).  
\- **Batch Import**: Though initial focus is one part at a time, the backend logic should allow batch operations (for future spreadsheet import). For now, after one part is imported, the user can proceed to the next scan.

## External API Details and Endpoints

### Mouser API (Part Search)

Mouser's Search API will be used to retrieve part data by part number. The relevant endpoint is:  
\- **Endpoint**: POST <https://api.mouser.com/api/v1/search/partnumber?apikey=&lt;API_KEY>&gt;  
\- **Authentication**: Uses an API Key (provided as a URL parameter). We will obtain a _Search API key_ from Mouser's API portal (which is separate from Mouser's Cart API key)[\[28\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=Mouser%20API%20key).  
\- **Request Format**: The request body is JSON, e.g.:

{  
"SearchByPartNumberRequest": {  
"mouserPartNumber": "123-XYZ"  
}  
}

(Using the Mouser part number as provided on their site/packaging).  
\- **Response Data**: The response will contain a SearchResults object with potentially multiple Parts. In most cases of exact part number, there will be one result. Each part entry includes numerous fields as listed in Mouser's documentation, such as: **MouserPartNumber**, **ManufacturerPartNumber**, **Manufacturer** (Name), **Availability** (stock), **Description**, **Category** (and possibly category hierarchy), **DataSheetUrl**, **ImageUrl**, **RoHSStatus**, **LifecycleStatus**, **MinOrderQty**, **Multiples**, **LeadTimeWeeks**, **SuggestedReplacement**, **ProductDetailUrl**, and **PriceBreaks** with quantities and prices[\[10\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Packaging)[\[11\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,up%20to%204%20price%20breaks). The app will parse these fields. For example, from these we will use Manufacturer, MPN, Description, etc., and we'll note at least the first price break (unit price).  
\- **Rate Limits**: The Mouser API allows up to 30 calls/min and 1000 calls/day[\[29\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,to%201%2C000%20calls%20per%20day), which is more than sufficient for our use. We should still avoid unnecessary calls (e.g. only call after scanning or when user submits a query).  
\- **Example**: If a user scans a Mouser label with a DataMatrix code, the code might encode the Mouser Part #. We extract that (e.g. "595-0603-1%R10K" as a SKU) and call the API. The API returns the part details which we then show for confirmation.

### Digi-Key API (Product Info)

Digi-Key's Product Information API (v4) will provide data for Digi-Key references. Key points:  
\- **Endpoints**: Digi-Key's API offers several endpoints; we will primarily use: - **ProductDetails** (GET) - for retrieving a single product's full details by part number[\[30\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=GET). - Optionally **ProductPricing** (GET) - to retrieve price information by part number[\[31\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=GET), but ProductDetails may already include pricing (especially if _MyPricing_ is enabled for the account).  
\- If the exact part number is unknown or we have a partial, **KeywordSearch** (POST) can be used to search by keyword/MPN[\[32\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=POST). In most cases, we expect to have an exact SKU or MPN from the barcode, so ProductDetails is ideal.  
\- **Authentication**: Digi-Key requires OAuth 2.0. We will use a **Client Credentials** grant (non-interactive) to get a token. The steps are: 1. Register an application in Digi-Key's Developer portal (as a Production app, since the Sandbox has limitations)[\[33\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=You%20need%20a%20registration%20on,entry%20should%20look%20somehow%20like). Enable the _Product Information_ API for this app[\[15\]](https://github.com/30350n/inventree-part-import#:~:text=match%20at%20L401%20Register%20a,API%20for%20it). 2. Obtain the **Client ID** and **Client Secret** from the portal[\[34\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=activated). 3. Request a token by POSTing to Digi-Key's token URL with our client credentials (grant_type=client_credentials). The app will do this on startup or when the token expires. The token and token type (usually Bearer) are then used in subsequent API calls[\[16\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=DIGIKEY_CLIENT_ID%3Dos.getenv%28)[\[17\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=url%2C%20headers%20%3D%20%7B%20%22X,%7D%2C%20data%20%3D%20json.dumps%28data_payload). (The app should handle token expiration by caching and refreshing as needed; Digi-Key's tokens typically expire in a short time, e.g. 30 minutes.)  
Digi-Key also requires an **X-DIGIKEY-Client-Id** header on API calls to identify our application[\[17\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=url%2C%20headers%20%3D%20%7B%20%22X,%7D%2C%20data%20%3D%20json.dumps%28data_payload). - **Request Format**: For _ProductDetails_, we will call a GET endpoint with the part number as a parameter (exact endpoint format is given in their API docs; e.g., it might be something like GET /products/v4/productdetails/{partNumber} or a query parameter). For _KeywordSearch_, it's a POST with a JSON payload containing search keywords[\[35\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=data_payload%20%3D%20%7B%20,Id%22%3A%20client_id%2C%20%22authorization%22%3A%20%22Bearer%20%7Baccess_token%7D%22.format%28access_token%3Dtoken.get%28%22access_token).  
\- **Response Data**: The ProductDetails response will include the detailed specifications of the part: Digi-Key part number, manufacturer name and MPN, description, datasheet link, stock quantity, pricing (if authorized), and a list of product attributes (e.g. for a resistor: value, tolerance, power, package, temperature coefficient, etc.). These attributes come as an array of name/value pairs in the JSON. The app will extract the relevant ones to display and to map into InvenTree parameters.  
\- **Rate Limits**: Digi-Key's API has rate limits (the exact values depend on the account level, and they may limit calls per second/minute). We should ensure to handle HTTP 429 responses gracefully (e.g. backoff or notify user if limit exceeded), though for a low-volume internal tool this is unlikely to be an issue.  
\- **Example**: If a user scans a Digi-Key label's QR code, we might get the Digi-Key part number (SKU) like "DGK: 2156-XYZ" or an internal ID. Ideally, the code includes the Digi-Key part number; if not, the DataMatrix might contain an internal ID which Digi-Key's _Order APIs_ could use, but to keep it simple, we assume scanning yields a part number or the user can enter it. We then call ProductDetails with that SKU and display the returned specs (e.g. "10kΩ ±5% 1/4W resistor, 0603 package, Digi-Key #12345, Mfr Yageo RC0603JR-10K").

### InvenTree API (Part Creation & Links)

Integration with InvenTree is done via its REST API (which uses token-based auth or user credentials). We will configure the app with an **InvenTree API token** for a dedicated user account (e.g. an "Import Bot" user) that has permission to create parts. Key endpoints and usage:  
\- **Authentication**: The app will store the InvenTree instance URL (e.g. <https://inventree.itrocas.com/>) and an API token string. All API calls to InvenTree will include this token in the Authorization header (format: Token &lt;token&gt;). This token corresponds to a user who will be recorded as the creator of the imported parts. (InvenTree also supports session auth, but a token is straightforward for a server-to-server context[\[36\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=Parameter%20In%20Type%20Default%20Nullable,query%20boolean%20No)[\[37\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=,in%20child%20categories%20of%20the).)  
\- **Creating a Part**: Use POST /api/part/ to create a new Part object[\[26\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=,POST%20%2Fapi%2Fpart%2Fcategory). The JSON body will at minimum have: - name: Name of the part (often the description or a short title). - description: (optional) more detailed description if needed (could include key specs). - category: The numeric ID of the category (which we will determine via an earlier API call or configuration). - is_template: false (this is a normal part, not a template). - salable: false (if this is a component, not sold as finished product). - assembly: false (not an assembly). - purchaseable: true (since we can purchase this part). - virtual: false (not a virtual part). - Other flags: e.g. trackable if we want to track serials (usually false for generic parts), etc. These can default to InvenTree's standard for new parts.  
On success, the API returns the new part's ID and data.  
\- **Creating Supplier Part**: The InvenTree API for supplier parts is under the **company** app. We likely will call POST /api/company/part/ or a similar endpoint (the exact endpoint might be /api/company/supplier-part/). According to InvenTree docs, there is an endpoint to create a supplier part by providing the part, the supplier (company ID), manufacturer (company ID) if any, SKU, MPN, etc. For example, InvenTree's "supplier mixin" plugin uses such data to create supplier parts[\[38\]](https://docs.inventree.org/en/1.1.x/plugins/mixins/supplier/#:~:text=Supplier%20Mixin%20,Creating%20supplier%20price). We will need to provide: - part: the InvenTree Part ID (from the part creation step). - supplier: the company ID for Mouser or Digi-Key. - SKU: the supplier's part number. - manufacturer: (optional) the company ID of the manufacturer. - MPN: (optional) manufacturer part number. - note: (optional) any note, could be the supplier's description or a reference. - Price breaks: we can add pricing by also calling the pricing API or including initial price data if the endpoint supports it. Alternatively, after creating the supplier part, we can call POST /api/part/pricing/ or a similar endpoint to add price information for that supplier part.  
\- **Fetching Categories/Parameters**: To facilitate mapping, the app can use GET endpoints: - GET /api/part/category/ - to retrieve the list of categories (possibly filtering by name or parent to find matching nodes). - GET /api/part/parameter/template/ - to get parameter definitions (so we know the IDs/names of "Resistance", "Capacitance", etc., and use them when creating Part Parameters). - POST /api/part/parameter/ - to create a parameter value for the part (linking to the template and providing the value). We will call this for each key parameter we want to store.  
\- **Verification**: After a successful import, the new part should appear in the InvenTree web interface with all provided details. The app might display a confirmation message or even a direct link to the part's page in InvenTree for convenience.

## User Interface & Workflow Design

**Layout**: The web app will likely be a single-page application (SPA) for responsiveness. A possible tech stack is **Django** (backend) + **React** (frontend), since the team is familiar with those technologies (Django can serve as an API backend and React for the interactive UI). The app will run as a separate service but within the same Docker setup as InvenTree, accessible via a subdomain (e.g. import.inventree.itrocas.com) per the deployment requirements.

**Workflow**:  
1\. **Scan or Enter Part Reference**: The main screen presents a clear input field and a scan button. The user can either type/paste a part number or click a "Scan" button to activate camera scanning. There should also be a toggle or buttons to select the supplier (Mouser vs Digi-Key) unless we auto-detect from the format. For HID scanner use, the input field will be auto-focused and can trigger the search on "Enter" (scanners typically append an enter key).  
2\. **Retrieve Data**: Once a reference is submitted, the app displays a loading indicator and calls the appropriate supplier API. If needed, intermediate steps like obtaining an OAuth token for Digi-Key are handled in the background.  
3\. **Display & Confirm**: The app then shows a form populated with the retrieved data. This form might be organized in sections: - _Basic Info_: Part Name/Description, Manufacturer, MPN, Supplier, SKU.  
\- _Category_: Suggested InvenTree category (with option to change via a dropdown or auto-complete search). If the suggestion is uncertain (e.g. no direct match), highlight the field for user input.  
\- _Specifications_: Key attributes like value, package, etc., possibly in a table of "Parameter - Value" pairs. Users can deselect any they don't want to import. - _Pricing_: Show the supplier's price (e.g. single-unit price and any bulk break if available). Allow the user to adjust or confirm the currency/region if needed. By default, prices will be in Euro for Portugal (see Localization). Optionally, allow entering a custom price if the user has negotiated pricing, etc.  
\- _Images/Docs_: If an image URL is available, show a small thumbnail. Provide link to datasheet. (These are for reference; InvenTree allows attaching images or datasheets, which could be a future extension to automatically download and attach the datasheet PDF or image to the part record.)  
Everything should be editable in case the user wants to tweak the info before saving. For example, they might shorten the auto-generated name or add an internal part number (IPN) as part of the name.  
4\. **Import Action**: A prominent **"Import Part"** button finalizes the process. When clicked, it will call the InvenTree API to create the part and related records. During this step, the app should give feedback (e.g. "Importing…") and then report success or any errors. On success, it might show _"Part added to InvenTree!"_ with a link to view it. The form then can reset or allow the user to import another part.  
5\. **Continuous Scanning**: To speed up multiple entries, after a successful import, the app could return focus to the input scan field to immediately scan the next item. This way, an inventory operator could scan one bag after another in sequence without using the mouse, if desired.  
6\. **Accessibility & Responsiveness**: The design will be mobile-friendly (since using phone camera is a key use case) as well as desktop-friendly. Buttons will be large enough for touch, and the layout should adjust to smaller screens. Keyboard shortcuts (like pressing Enter to submit, or Esc to cancel) should be supported to streamline use for power users.

## Deployment and Configuration

- **Integration with InvenTree Server**: The app will be deployed in the same environment as the InvenTree instance (inventree.itrocas.com). It will run as a separate web service (for example, a Django app running on a different port) but will be exposed under a convenient subdomain via reverse proxy (nginx or similar). For instance, import.inventree.itrocas.com will point to this app's UI. This integration means we can potentially reuse some of InvenTree's infrastructure (like the database if needed, though that's not required for read-only access to categories; mostly the app is an API client to InvenTree). Running in the same Docker compose ensures low-latency network calls between the importer and the InvenTree API (they can communicate over the Docker network).
- **Tech Stack**: Django (Python) for the backend is suggested, which can handle the supplier API calls (keeping API keys secure on the server side) and the InvenTree API interactions. The frontend could be built in React for a dynamic user experience. The choice of React is in line with familiarity and allows using component libraries for barcode scanning and forms. However, the exact framework is flexible as long as the result is intuitive and maintainable. The backend will expose endpoints that the frontend can call (e.g. /api/importer/search/mouser?code=XYZ), or we might implement it as a traditional Django view with server-side rendering and some JS enhancements for scanning. The separation of concerns will keep supplier API keys hidden (calls are made server-side).
- **Configuration**: A configuration file or environment variables will be used for:
- _Mouser API Key_: Provided by the user and stored securely (e.g. MOUSER_API_KEY).
- _Digi-Key API Credentials_: Client ID and Client Secret (e.g. DIGIKEY_CLIENT_ID and DIGIKEY_CLIENT_SECRET). The OAuth token will be fetched as needed; if Digi-Key provides a refresh token or requires an OAuth callback, we'll handle that accordingly (Digi-Key's client credential flow does not require user interaction, so no callback URL is needed for this specific case).
- _InvenTree API Token_: The token for the service account ("bot user") that will perform the part creation. This can be set as INVENTREE_TOKEN. Also, the base URL for InvenTree (INVENTREE_BASE_URL) which is likely the same host but good to have configurable (in this case <https://inventree.itrocas.com/>).
- _Default Locale/Currency_: A setting for default country/currency for pricing. Since the primary user is in Portugal, the app should default to **Portugal** as the region. This affects supplier API queries - for example, Mouser's API allows specifying a country or uses the API key's account region to return prices in local currency. The InvenTree Supplier Panel plugin notes that Mouser needs a country code to get the correct currency, and it selects the country based on the desired currency[\[39\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=). We will similarly default to Portugal (country code "PT") which yields prices in EUR. The app can allow this to be overridden in config or UI if needed (for instance, if one wants to see USD pricing or a different region's availability, they could change the setting). For Digi-Key, the API might automatically return pricing in the currency associated with the account (likely EUR for a European account). We will ensure the API calls include any parameters for locale if required (e.g. Digi-Key's API might infer from account or allow a region specification). In our config, we could have DEFAULT_CURRENCY=EUR, DEFAULT_COUNTRY=PT, and even DEFAULT_LANGUAGE=en (some APIs return data in a chosen language, though we'll mostly use English). These defaults mirror the CLI tool's settings for currency/language/location[\[40\]](https://github.com/30350n/inventree-part-import#:~:text=default%20locales,have%20to%20be%20set).
- **Security**: The app itself can be protected since it's an internal tool. We can integrate InvenTree's authentication (e.g. require the user to log in with their InvenTree credentials via the REST token or session) or simply keep it behind the company's firewall. A simple approach is to use InvenTree's user token in the config, which means any user with access to the web app UI can trigger imports under that account. If finer control is needed, we could add a login screen to the importer (perhaps leveraging Django's authentication or the InvenTree user database via API). Initially, this might not be necessary if only trusted users know the URL. But for completeness, consider at least HTTP basic auth or similar if exposed publicly.
- **Logging & Monitoring**: The system should log actions (when a part is imported, log the part number and outcome) for traceability. In case of errors from supplier APIs or the InvenTree API, these should be logged and shown to the user in a friendly manner (e.g. "Failed to fetch data from Mouser: API key invalid" or "Failed to create part: category ID not found").

## Future Enhancements and Considerations

- **Spreadsheet/Bulk Import**: A future version will allow importing a list of parts from a file (CSV or Excel). The design should leave room for an "Import from Spreadsheet" option. For example, a page where a user can upload a file with a list of part numbers and the app will batch process them. We might reuse much of the same logic: for each row, call the APIs and either auto-import or prepare a summary for user review. The UI might show a preview of multiple parts and allow editing them in bulk before importing. While this is a later addition, the architecture should separate the data-fetch logic so it can handle multiple parts easily (the CLI already supports batch CSV import[\[41\]](https://github.com/30350n/inventree-part-import#:~:text=%24%20inventree,)). We'll keep the code modular to accommodate this.
- **Serial Port Scanner Support**: Currently, we will support USB barcode scanners in keyboard mode. In future, if a serial (RS232/UART) scanner or a Bluetooth scanner that doesn't act as HID needs to be used, we might need additional backend support to read from that interface. This is likely low priority (most scanners can act as HID or we can use a serial-to-USB adapter and read via the server). For now, we note that adding a service to read from a serial port and feed data to the web app is possible later.
- **Additional Suppliers**: The initial scope is Mouser and Digi-Key, but the system could be extended to other distributors (the CLI tool, for example, supports LCSC, TME, Reichelt, etc.). The design should allow adding new supplier modules easily. For instance, a unified interface like fetchPartData(supplier, code) that can call the appropriate API or even do web-scraping if no API is available (LCSC has no official API, but scraping or community APIs exist[\[42\]](https://github.com/maholli/getparts#:~:text=barcodes%20for%20,Can%27t%20extract%20anything%20useful%20from)). Our UI can have a supplier selector that could include more options in the future.
- **Enhanced Parameter Handling**: Over time, as we refine the category mapping, we can build a configuration of which parameters to record for each category. For example, for resistors, record Resistance, Tolerance, Power; for capacitors, Capacitance, Voltage, Dielectric, etc. This could be driven by a config file or even an interactive mapping (like the CLI's categories.yaml and parameters.yaml allow aliasing and default parameters[\[24\]](https://github.com/30350n/inventree-part-import#:~:text=_structural%3A%20true%20,the%20%27Ceramic%27%20and%20%27Electrolytic%27%20categories)). In the immediate term, we might only handle a few common fields, but the infrastructure is there to expand.
- **User Overrides and Edits**: We assume the API data is correct, but users might want to override certain fields. The UI should allow that (already mentioned for name, etc.). In future, we could add features like if the part already exists in InvenTree, offering to update data (for instance, update its parameters or pricing).
- **Performance**: For single-part import the performance is more than enough (each import involves a couple of external API calls). In a scenario of bulk import, we might need to consider throttling (especially with API rate limits) and perhaps caching common lookups (like category mappings or previously seen parts). If a user scans the same part twice, perhaps we can detect it and avoid duplicate imports (maybe by checking if MPN already exists in InvenTree).
- **Testing Mode**: It might be useful to have a "dry run" mode in future, especially for bulk imports - where the app shows what would be imported without actually creating records. During initial development, we can test against Digi-Key's sandbox (which requires using sandbox endpoints and keys) before switching to production APIs.

## Localization & Pricing Considerations

The application will primarily serve the needs of a Portugal-based user, so defaults will be set accordingly:  
\- **Default Currency/Region**: Euro (€) and Portugal as the country. This means the pricing we retrieve from suppliers will be the Euro pricing (Mouser, for example, returns prices in the currency of the country code used - Portugal yields EUR). The InvenTree instance likely is configured with EUR as default currency. We will ensure that when adding price data to InvenTree, we mark it as EUR. If needed, the user can change the region in settings (for example, if a user in another region uses the tool, they might switch to USD/USA, etc.).  
\- **Tax and Shipping**: Generally, the supplier APIs give unit prices excluding taxes. We will not complicate the import with tax; InvenTree's pricing is usually pre-tax. If needed, the user can adjust pricing or add cost information later in InvenTree (our tool's focus is on part data, not purchase orders).  
\- **Language**: Supplier data will be retrieved in English (both Mouser and Digi-Key provide English descriptions by default or based on account settings). Since technical data is usually in English, we will stick to that. If needed, adding localization for the app's UI (Portuguese labels, etc.) can be considered, but likely the user is fine with English UI for this technical tool.  
\- **Units and Formatting**: We will present values in a clear way (e.g. "10 kΩ" or "0.1 µF"). The data from APIs might be in strings already formatted; we'll use them as-is. Ensuring the use of proper decimal separators, etc., according to locale is minor since these are standard engineering format strings.

By adhering to these requirements and design principles, the resulting web app will **significantly simplify the process of adding new parts** to the inventory. Users will be able to go from a distributor's label or reference number to a fully populated InvenTree part record in seconds. This not only saves time but also improves data consistency (using the official part names and specs from the supplier). The system builds upon proven approaches from existing tools (like Maholli's _getparts_ for barcode decoding and 30350n's _inventree-part-import_ for data mapping) and integrates them in a user-friendly web interface.

Overall, this importer tool will make inventory management more efficient and error-free, encouraging broader use of InvenTree for keeping track of electronic components. All the heavy lifting - from calling supplier APIs to mapping fields - happens behind the scenes, presenting a simple and intuitive experience for the user.

**Sources:** The design draws on the functionality of open-source projects and official API documentation: supplier barcode tools[\[1\]](https://github.com/maholli/getparts#:~:text=Nearly%20every%20electrical%20component%20ordered,with%20and%20without%20search%20API)[\[4\]](https://github.com/maholli/getparts#:~:text=,and), InvenTree community discussions on ease-of-use[\[2\]](https://github.com/inventree/InvenTree/issues/677#:~:text=I%20wanted%20to%20get%20this,to%20reinvent%20the%20wheel%20here), the InvenTree Part Import CLI README[\[43\]](https://github.com/30350n/inventree-part-import#:~:text=To%20import%20parts%2C%20simply%20use,parts%20you%20want%20to%20import)[\[22\]](https://github.com/30350n/inventree-part-import#:~:text=temporarily%20blocked%29%20,dataclass), and supplier API references (Mouser Search API data fields[\[10\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Packaging)[\[11\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,up%20to%204%20price%20breaks), Digi-Key ProductInfo API overview[\[30\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=GET), etc.), as cited throughout.

[\[1\]](https://github.com/maholli/getparts#:~:text=Nearly%20every%20electrical%20component%20ordered,with%20and%20without%20search%20API) [\[3\]](https://github.com/maholli/getparts#:~:text=Always%20starts%20with%20%60%5B%29%3E%60%20,and) [\[4\]](https://github.com/maholli/getparts#:~:text=,and) [\[5\]](https://github.com/maholli/getparts#:~:text=data%20matrix%20format.%20,Invoice%20No) [\[42\]](https://github.com/maholli/getparts#:~:text=barcodes%20for%20,Can%27t%20extract%20anything%20useful%20from) GitHub - maholli/getparts: Python tool for retrieving electrical component info from supplier barcodes (Digi-Key, Mouser, LCSC)

<https://github.com/maholli/getparts>

[\[2\]](https://github.com/inventree/InvenTree/issues/677#:~:text=I%20wanted%20to%20get%20this,to%20reinvent%20the%20wheel%20here) \[Discussion\] Adding parts and manipulating stock w/ API · Issue #677 · inventree/InvenTree · GitHub

<https://github.com/inventree/InvenTree/issues/677>

[\[6\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Method) [\[7\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,to%201%2C000%20calls%20per%20day) [\[10\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Packaging) [\[11\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,up%20to%204%20price%20breaks) [\[18\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,Packaging) [\[29\]](https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK#:~:text=,to%201%2C000%20calls%20per%20day) Search API

<https://www.mouser.com/api-search/?srsltid=AfmBOooDs4loXzRSvg-Gw3cNazlnX3pkLnvQfB9Pj0Du9g-y8ZQ9tZMK>

[\[8\]](https://stackoverflow.com/questions/75205725/no-search-results-while-using-api-key-to-retrieve-information-using-python#:~:text=data%20%3D%20%7B%20,part_number%20%7D) No search results while using API Key to retrieve information using Python - Stack Overflow

<https://stackoverflow.com/questions/75205725/no-search-results-while-using-api-key-to-retrieve-information-using-python>

[\[9\]](https://github.com/30350n/inventree-part-import#:~:text=match%20at%20L408%20Request%20a,from%20the%20Mouser%20API%20Hub) [\[15\]](https://github.com/30350n/inventree-part-import#:~:text=match%20at%20L401%20Register%20a,API%20for%20it) [\[20\]](https://github.com/30350n/inventree-part-import#:~:text=,defaults%20to%20category%20name) [\[21\]](https://github.com/30350n/inventree-part-import#:~:text=_aliases%3A%20,SMD) [\[22\]](https://github.com/30350n/inventree-part-import#:~:text=temporarily%20blocked%29%20,dataclass) [\[23\]](https://github.com/30350n/inventree-part-import#:~:text=%2A%20%60_ignore%60%20makes%20%60inventree,yaml%29%20this%20category%20uses) [\[24\]](https://github.com/30350n/inventree-part-import#:~:text=_structural%3A%20true%20,the%20%27Ceramic%27%20and%20%27Electrolytic%27%20categories) [\[25\]](https://github.com/30350n/inventree-part-import#:~:text=in%20interactive%20mode%20,MPN) [\[40\]](https://github.com/30350n/inventree-part-import#:~:text=default%20locales,have%20to%20be%20set) [\[41\]](https://github.com/30350n/inventree-part-import#:~:text=%24%20inventree,) [\[43\]](https://github.com/30350n/inventree-part-import#:~:text=To%20import%20parts%2C%20simply%20use,parts%20you%20want%20to%20import) GitHub - 30350n/inventree-part-import: CLI to import parts from suppliers like DigiKey, LCSC, Mouser, etc. to InvenTree

<https://github.com/30350n/inventree-part-import>

[\[12\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=ProductDetails) [\[13\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=i%20%20Learn%20More) [\[14\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=Enter%20parameters%2C%20keywords%2C%20or%20a,that%20MyPricing%20is%20not%20returned) [\[19\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=Enter%20a%20manufacturer%20part%20number%2FDigiKey,MyPricing%20is%20shown%20if%20applicable) [\[30\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=GET) [\[31\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=GET) [\[32\]](http://developer.digikey.com/products/product-information-v4/productsearch#:~:text=POST) ProductSearch | API Developer Portal

<http://developer.digikey.com/products/product-information-v4/productsearch>

[\[16\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=DIGIKEY_CLIENT_ID%3Dos.getenv%28) [\[17\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=url%2C%20headers%20%3D%20%7B%20%22X,%7D%2C%20data%20%3D%20json.dumps%28data_payload) [\[35\]](https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/#:~:text=data_payload%20%3D%20%7B%20,Id%22%3A%20client_id%2C%20%22authorization%22%3A%20%22Bearer%20%7Baccess_token%7D%22.format%28access_token%3Dtoken.get%28%22access_token) Digikey Basic Product Search Script (Targeting Digikey API v4)

<https://briankhuu.com/blog/2024/09/17/playing-around-with-digikey-api/>

[\[26\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=,POST%20%2Fapi%2Fpart%2Fcategory) [\[36\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=Parameter%20In%20Type%20Default%20Nullable,query%20boolean%20No) [\[37\]](https://docs.inventree.org/en/latest/api/schema/part/#:~:text=,in%20child%20categories%20of%20the) Parts and Part Categories - InvenTree Documentation

<https://docs.inventree.org/en/latest/api/schema/part/>

[\[27\]](https://docs.inventree.org/en/stable/part/#:~:text=Parts%20,parts%20to%20be%20ordered) Parts - InvenTree Documentation

<https://docs.inventree.org/en/stable/part/>

[\[28\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=Mouser%20API%20key) [\[33\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=You%20need%20a%20registration%20on,entry%20should%20look%20somehow%20like) [\[34\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=activated) [\[39\]](https://inventree.org/SergeoLacruz/inventree-supplier-panel#:~:text=) InvenTree - Inventree Supplier Panel

<https://inventree.org/SergeoLacruz/inventree-supplier-panel>

[\[38\]](https://docs.inventree.org/en/1.1.x/plugins/mixins/supplier/#:~:text=Supplier%20Mixin%20,Creating%20supplier%20price) Supplier Mixin - InvenTree Documentation

<https://docs.inventree.org/en/1.1.x/plugins/mixins/supplier/>
